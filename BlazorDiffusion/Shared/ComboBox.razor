@using System.Linq.Expressions
@typeparam T
@inherits TextInputBase
@inject IJSRuntime JS

<div id=@($"{Id}-combobox")>
    @if (!string.IsNullOrEmpty(Label))
    {
        <label for=@Id class="block text-sm font-medium text-gray-700 dark:text-gray-300">@Label</label>
    }
    <div class="relative mt-1">
        <input id=@Id type="text" @bind="value" class="w-full rounded-md border border-gray-300 dark:border-gray-300 bg-white dark:bg-black py-2 pl-3 pr-12 shadow-sm focus:border-indigo-500 focus:outline-none focus:ring-1 focus:ring-indigo-500 sm:text-sm"
                role="combobox" aria-controls="options" aria-expanded="false" placeholder=@placeholder @bind:event="oninput" @onkeydown="OnKeyDown" @onkeyup="OnKeyUp" @onclick="update">
        <button type="button" @onclick="toggle" class="absolute inset-y-0 right-0 flex items-center rounded-r-md px-2 focus:outline-none">
            <svg class="h-5 w-5 text-gray-400 dark:text-gray-500" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor" aria-hidden="true">
                <path fill-rule="evenodd" d="M10 3a.75.75 0 01.55.24l3.25 3.5a.75.75 0 11-1.1 1.02L10 4.852 7.3 7.76a.75.75 0 01-1.1-1.02l3.25-3.5A.75.75 0 0110 3zm-3.76 9.2a.75.75 0 011.06.04l2.7 2.908 2.7-2.908a.75.75 0 111.1 1.02l-3.25 3.5a.75.75 0 01-1.1 0l-3.25-3.5a.75.75 0 01.04-1.06z" clip-rule="evenodd" />
            </svg>
        </button>
    @if (showPopup)
    {
        <ul class="absolute z-10 mt-1 max-h-60 w-full overflow-auto rounded-md bg-white dark:bg-black py-1 text-base shadow-lg ring-1 ring-black ring-opacity-5 focus:outline-none sm:text-sm" id="options" role="listbox">
        @foreach (var option in FilteredValues)
        {
            <li class=@ClassNames(option.Equals(active) ? "active bg-indigo-600 text-white" : "text-gray-900 dark:text-gray-100", "relative cursor-default select-none py-2 pl-3 pr-9")
                @onmouseover="_ => setActive(option)" @onclick="_ => select(option)" role="option" tabindex="-1">
                @Item!(option)
            @if (Values.Contains(option))
            {
                <span class=@ClassNames("absolute inset-y-0 right-0 flex items-center pr-4", option.Equals(active) ? "text-white" : "text-indigo-600")>
                    <svg class="h-5 w-5" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor" aria-hidden="true">
                        <path fill-rule="evenodd" d="M16.704 4.153a.75.75 0 01.143 1.052l-8 10.5a.75.75 0 01-1.127.075l-4.5-4.5a.75.75 0 011.06-1.06l3.894 3.893 7.48-9.817a.75.75 0 011.05-.143z" clip-rule="evenodd" />
                    </svg>
                </span>
            }
            </li>
        }
        </ul>
    }
    @if (HasErrorField)
    {
        <div class="absolute inset-y-0 right-0 pr-3 flex items-center pointer-events-none">
            <svg class="h-5 w-5 text-red-500" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor" aria-hidden="true">
                <path fill-rule="evenodd" d="M18 10a8 8 0 11-16 0 8 8 0 0116 0zm-7 4a1 1 0 11-2 0 1 1 0 012 0zm-1-9a1 1 0 00-1 1v4a1 1 0 102 0V6a1 1 0 00-1-1z" clip-rule="evenodd" />
            </svg>
        </div>
    }
    </div>
    @if (HasErrorField)
    {
        <p class="mt-2 text-sm text-red-500" id=@($"{Id}-error")>@ErrorFieldMessage</p>
    }
    else if (!string.IsNullOrEmpty(UseHelp))
    {
        <p id=@($"{Id}-description") class="text-gray-500">@UseHelp</p>
    }
</div>


@code {
    [Parameter] public int ViewCount { get; set; } = 100;
    [Parameter] public int PageSize { get; set; } = 8;

    [Parameter] public List<T>? Options { get; set; }
    [Parameter] public List<T> Values { get; set; } = new();
    [Parameter, EditorRequired] public Func<T,string,bool>? Match { get; set; }
    [Parameter, EditorRequired] public RenderFragment<T>? Item { get; set; }
    [Parameter] public Expression<Func<List<T>>>? ValuesExpression { get; set; }
    [Parameter] public EventCallback<List<T>> ValuesChanged { get; set; }

    string? value;
    bool showPopup = false;
    T? active;
    int take = int.MaxValue;

    List<T> FilteredValues = new();

    List<T> filterOptions() => Options == null
        ? new List<T>()
        : (string.IsNullOrEmpty(value)
            ? Options
            : Options.Where(x => Match!(x, value))).Take(take).ToList();

    IEnumerable<T> exclude(IEnumerable<T> results) => string.IsNullOrEmpty(value)
        ? results
        : results.Where(x => !Match!(x, value));

    string[] NavKeys = new[] { "Escape", "ArrowDown", "ArrowUp", "Enter", "PageUp", "PageDown", "Home", "End" };

    void setActive(T item)
    {
        active = item;
        var currIndex = FilteredValues.IndexOf(active);
        if (currIndex > Math.Floor(take * .9))
        {
            take += ViewCount;
            refresh();
        }
    }

    void OnKeyUp(KeyboardEventArgs e)
    {
        if (NavKeys.Contains(e.Code))
            return;

        update();
    }

    async Task OnKeyDown(KeyboardEventArgs e)
    {
        if (!showPopup)
        {
            if (e.Code == "ArrowDown")
            {
                showPopup = true;
                active = FilteredValues.FirstOrDefault();
            }

            return;
        }

        if (e.Code == "Escape")
        {
            showPopup = false;
        }
        else if (e.Code == "Home")
        {
            active = FilteredValues.FirstOrDefault();
            await scrollActiveIntoView();
        }
        else if (e.Code == "End")
        {
            active = FilteredValues.LastOrDefault();
            if (active != null)
                setActive(active);
            await scrollActiveIntoView();
        }
        else if (e.Code == "PageUp")
        {
            if (active != null)
            {
                var currIndex = FilteredValues.IndexOf(active);
                var nextIndex = currIndex - PageSize;
                active = FilteredValues[Math.Max(nextIndex, 0)];
                await scrollActiveIntoView();
            }
        }
        else if (e.Code == "PageDown")
        {
            if (active != null)
            {
                var currIndex = FilteredValues.IndexOf(active);
                var nextIndex = currIndex + PageSize;
                setActive(FilteredValues[Math.Min(nextIndex, FilteredValues.Count - 1)]);
                await scrollActiveIntoView();
            }
        }
        else if (e.Code == "ArrowDown")
        {
            if (active == null)
            {
                active = FilteredValues.FirstOrDefault();
            }
            else
            {
                var currIndex = FilteredValues.IndexOf(active);
                active = currIndex + 1 < FilteredValues.Count
                    ? FilteredValues[currIndex + 1]
                    : FilteredValues.FirstOrDefault();
            }
        }
        else if (e.Code == "ArrowUp")
        {
            if (active == null)
            {
                active = FilteredValues.LastOrDefault();
            }
            else
            {
                var currIndex = FilteredValues.IndexOf(active);
                active = currIndex - 1 >= 0
                    ? FilteredValues[currIndex - 1]
                    : FilteredValues.LastOrDefault();
            }
        }
        else if (e.Code == "Enter")
        {
            if (active != null)
            {
                await select(active);
            }
            else
            {
                showPopup = false;
            }
        }
    }

    async Task scrollActiveIntoView(int delayMs = 10) {
        await JS.InvokeVoidAsync("JS.elInvokeDelay", $"#{Id}-combobox li.active", "scrollIntoView", new { scrollMode = "if-needed" }, delayMs);
    }

    void FilterResults(KeyboardEventArgs e) => update();

    void toggle() 
    {
        if (showPopup)
        {
            showPopup = false;
            return;
        }
        update();
    }

    void update() 
    {
        showPopup = true;
        refresh();
        StateHasChanged();
    }

    async Task select(T option)
    {
        value = null;
        showPopup = false;
        if (Values.Contains(option))
            Values.Remove(option);
        else
            Values.Add(option);
        active = default;
        await ValuesChanged.InvokeAsync(Values);
    }

    protected override async Task OnParametersSetAsync()
    {
        take = ViewCount;
        await base.OnParametersSetAsync();
        refresh();
    }

    void refresh() {
        FilteredValues = filterOptions();
    }

    public override Task SetParametersAsync(ParameterView parameters)
    {
        parameters.SetParameterProperties(this);

        if (!_hasInitializedParameters)
        {
            // This is the first run
            // Could put this logic in OnInit, but its nice to avoid forcing people who override OnInit to call base.OnInit()
            if (ValuesExpression == null)
            {
                throw new InvalidOperationException($"{GetType()} requires a value for the 'ValuesExpression' " +
                                                    $"parameter. Normally this is provided automatically when using 'bind-Values'.");
            }

            FieldIdentifier = Microsoft.AspNetCore.Components.Forms.FieldIdentifier.Create(ValuesExpression);
            if (Id == null)
                Id = FieldIdentifier.FieldName;

            _nullableUnderlyingType = Nullable.GetUnderlyingType(typeof(T));
            _hasInitializedParameters = true;
        }

        // For derived components, retain the usual lifecycle with OnInit/OnParametersSet/etc.
        return base.SetParametersAsync(ParameterView.Empty);
    }
}

